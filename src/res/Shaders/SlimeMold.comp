#version 460 core

layout (local_size_x = 16, local_size_y = 1, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D screen;
layout (rgba32f, binding = 1) uniform image2D trail;

struct Particle {
    vec4 position;
    vec4 color;
};

layout (binding = 1) buffer SSBO_1 {
    Particle particles[];
};

uniform uint time;
uniform uint count;
uniform float deltaTime;

uint hash(uint state) {
        state ^= 2747636419u;
        state *= 2654435769u;
        state ^= state >> 16;
        state *= 2654435769u;
        state ^= state >> 16;
        state *= 2654435769u;
        return state;
}

uint pRandNum(uint min, uint max, uint hashState) {
    uint randNum = hash(hashState);
    uint clampedNum = randNum % (max - min + 1) + min;
    return clampedNum;
}

void update(float dT) {
    float PI = 3.151594;
    ivec2 id = ivec2(gl_GlobalInvocationID.xy);
    uint screenArea = (1920 / 2) * (1080 / 2);
    uint state = id.x * time * screenArea;

    float speed = 100.0f;
    float rateOfChange = deltaTime * speed;

    vec2 pos = particles[id.x].position.xy;
    float rotation = particles[id.x].position.w;
    vec2 direction = vec2(cos(rotation), -sin(rotation));

    vec2 newPos = pos + (direction * rateOfChange);

    if (newPos.x < 0 || newPos.x >= 960 || newPos.y < 0 || newPos.y >= 540) {
        newPos.x = min(960 - 0.01, max(0, newPos.x));
        newPos.y = min(540 - 0.01, max(0, newPos.y));
        particles[id.x].position.w = pRandNum(0, 360, state);
    }

    particles[id.x].position.xy = newPos;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    vec4 pixel = vec4(0.0f, 0.0f, 0.0f, 1.0f);

    if (gl_GlobalInvocationID.x < count) {
        update(deltaTime);
        vec2 position = particles[gl_GlobalInvocationID.x].position.xy;
        pixelCoords = ivec2(position.x, position.y);
        pixel = particles[gl_GlobalInvocationID.x].color;
    }

    imageStore(screen, pixelCoords, pixel);
    imageStore(trail, pixelCoords, pixel);
}
